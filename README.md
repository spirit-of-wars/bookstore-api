Оглавление
=============================================================
* [Установка nginx](#nginx)  
* [Установка php](#php)
* [Установка и настройка XDebug](#xdebug)
* [Установка проекта без web-сервера](#withoutNginx)
* [Установка проекта с использованием nginx](#withNginx)
* [Файл .env.local.php](#env)
* [Особенности работы с моделями](#entity)
* [Добавленные типы данных](#newTypeData)
* [Описания к полям моделей](#aboutAttributes)
* [Проектирование контроллера](#developController)
* [Актуализация документации (в сваггере)](#swagger)
* [Особенности работы с doctrine в проекте](#persistHolder)
* [Особенности DI в проекте](#di)
* [Принципы код ревью](#codeReview)
* [Принципы документирования проекта](#projDoc)
* [Полезные команды](#console)

Установка проекта
==============================================================

<a name="deploy"><h2>Установка nginx</h2></a>
> Используется если проект будет развернут на базе сервера nginx а не на встроенном сервере php

1. `sudo apt-get install nginx` : Устанавливаем nginx

2. Настраиваем nginx (+ не забыть добавить новый сервер в /etc/hosts):   
```conf
server {  
    charset utf-8;  
    client_max_body_size 128M;  
    listen 80;  
    listen [::]:80;  
    server_name mifapi;  
    root /home/................./mif-api;  
    index public/index.php;  
    location / {  
        try_files $uri /public/index.php?$args;  
    }  
    location ~ \.php$ {  
        include fastcgi_params;  
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;  
        fastcgi_pass unix:/run/php/php7.4-fpm.sock;  
    }  
} 
```

<a name="php"><h2>Установка php</h2></a>
1. `sudo apt -y install php7.4` : Устанавливаем php7.4 
2. `sudo apt-get install php7.4-gd php7.4-mysql php7.4-xml php7.4-mbstring php7.4-fpm` : Устанавливаем php-расширения 


<a name="xdebug"><h2>Установка и настройка XDebug</h2></a>
1. `sudo apt install php-xdebug` : Устанавливаем пакет xdebug
2. добавить настройки в файл `/etc/php/7.4/mods-available/xdebug.ini`
- xdebug.remote_enable = 1;
- xdebug.remote_port = 9001;
- xdebug.remote_autostart = 1;
3. перезапустить ftp-сервис `sudo service php7.4-fpm restart`
##### Настройка дебагера в проекте #####
1. Settings->Languages...->PHP->Debug - здесь установить порт
2. Создать PHP Web Application, host - server_name из настроек nginx

<a name="withoutNginx"><h2>Установка проекта без web-сервера</h2></a>            

1. `/usr/bin/php7.4 /usr/local/bin/composer install` : Устанавливаем composer зависимости (подразумевается что композер уже был установлен. Если нет - надо поставить)
2. `sudo wget https://get.symfony.com/cli/installer -O - | bash` : Установка symfony для запуска встроенного сервера
3. `sudo mv /home/ТУТ_ВАШЕ_ИМЯ_ЮЗЕРА/.symfony/bin/symfony /usr/local/bin/symfony` : Выполняем это чтобы команда symfony стала доступна без полного пути (замените ТУТ_ВАШЕ_ИМЯ_ЮЗЕРА на свое)
4. `sudo touch .env.local` : Создаем в корне проекта локальный файл конфигурации окружения (тут укажем доступы к бд. Скопируем строку DATABASE_URL из файла .env и подставим свои значения) 
5. Настраиваем базу данных.
6. `php7.4 bin/console doctrine:migrations:migrate` : Накатываем миграции
  
`symfony server:start` : Стартуем веб-сервер

<a name="withNginx"><h2>Установка проекта с использованием nginx</h2></a> 

1. `composer install` : Устанавливаем composer зависимости
2. Создаем в корне проекта локальный файл конфигурации окружения `.env.local.php` тут укажем тип окружения, доступы к бд, хост, некоторые настройки для сваггера...
3. Настраиваем базу данных.
4. `bin/console doctrine:migrations:migrate` : Накатываем миграции

<a name="env"><h2>Файл .env.local.php</h2></a> 

В корне проекта есть файл .env.local.php.example в нем отражена вся структура переменных
    
<a name="entity"><h2>Особенности работы с моделями</h2></a> 

1. Создаем спецификацию модели в файле `/util/Entity/XXX.yaml`, где `XXX` - имя модели
Пример спецификации:

    ```yaml
    # здесь имя модели должно совпадать с именем файла (XXX в примере выше)
    name: Product
    # можно добавлять поведения
    behaviors:
      # у модели будут поля 'createdAt' и 'updatedAt' и они будут актуализироваться автоматически
      - ChangeTimeSavingBehavior
    # Так же можно добавлять интерфейсы к модели
    interfaces:
      - App\FullNamespace\Interface
    # можно задать определители, которые применятся к атрибутам, в которых эти определители не указаны явно
    defaults:
      nullable: false
    attributes:
      # на первом месте в определении поля - его тип
      # в скобках указывается размер поля, если это нужно. Для строк 255 - значение по умолчанию
      name: string(255)
      # можно указать валидационные ограничения, н-р принадлежность к перечислению
      # можно использовать стандартные ограничения https://symfony.ru/doc/current/validation.html
      # по ограничениям проекта см. пункт 1.2
      # синтаксис ограничения:
      # - фактически это имя класса без пространства имен
      # - скобки обязательны, даже если нет аргументов
      type: string Enum("ProductTypeEnum")
      # после определения типа могут идти дополнительные определители,
      # н-р "nullable" - поле может иметь значение "null"
      description: text nullable
      # определитель "!nullable" - поле не может иметь значение "null"
      # определитель "readonly" - для данного поля будет доступен только геттер, сеттера не будет
      typeAttrId: integer !nullable readonly
    relations:
      # Для подробностей см. пункт 1.3
      # Связь многие-к-одной, однонаправленная
      relName: manyToOne SomeEntity
      # Связь многие-к-одной, двунаправленная
      # Релейшен 'products' должен быть объявлен в спецификации модели 'AnotherEntity'
      anotherRelName: manyToOne AnotherEntity.products
      # Связь многие-ко-многим (может быть только двунаправленная)
      # Релейшен 'products' должен быть объявлен в спецификации модели 'Stuff'
      stuffs: manyToMany Stuff.products
    ```

   1.2. Собственные ограничения сущностей в проекте:
   В проекте можно создавать собственные ограничения для сущностей. О том как их создавать:
      - Класс от которого наследуются все ограничения `src/Validation/Constraint/AbstractConstraint`
      - Ограничение требует вилидатор
      - В качестве примера - пара классов `App\Validation\Constraint\Enum` и `App\Validation\ConstraintValidator\EnumValidator`

   1.3. Указание связей:
      - manyToMany - альтернативный синтаксис `(><)`. Может быть только двунаправленной.
      - oneToOne - альтернативный синтаксис `(--)`. Может быть однонаправленной и двунаправленной.
         В случае двунаправленной в одной из моделей нужно явно указать расположение внешнего ключа синтаксисом `(--fk)`.
      - manyToOne - альтернативный синтаксис `(>-)`. Может быть однонаправленной и двунаправленной.
      - oneToMany - альтернативный синтаксис `(-<)`. Может быть только двунаправленной.
      Двунаправленная связь подразумевает определение релейшена в спецификациях обеих моделей.
      Синтаксис выглядит следующим образом:
      <relationNameInThisModel>: <relationType> <relatedModelName>.<relationNameInRelatedModel>

2. Запускаем команду `bin/console entity:generate XXX`, где `XXX` - имя модели. Будут созданы php-файлы для модели и для репозитория (если он еще не был создан). Важно! Файл для модели в текущей реализации ПЕРЕСОЗДАЕТСЯ, поэтому код модели следует счиать сгенерированным автоматически, и не добавлять туда ручных правок. Для манипуляций с моделями рекомендуется создавать сервисы (смотреть сюда `/src/Service/Entity/`, наследовать от `App\Service\Entity\EntityService`). Для специфических выгрузок существует класс репозиторий для каждой модели (`/src/Repository/`). Такой подход выбран специально, чтобы не плодить бизнес-логику в моделях. Принцип единой ответственности: класс модели выполняет роль адаптера между бизнес-логикой и инструментом хранения данных в объектно-ориентированном стиле.  
    2.1 Альтернативно можно запустить команду `bin/console entity:generate` без параметров. Тогда будут проверены на актуальность все спецификации моделей, которые генератор сможет найти.  
    2.2 Доступно два флага для команды:  
     - --state (короткий вариант -s) - пересоздаваться файлы не будут. Команда только отобразит информацию о состоянии сущностей  
     - --update (короткий вариант -u) - команда будет отображать только то, что происходит с сущностями, требующими актуализации  

3. Далее всё как обычно для symfony - автогенерация новых миграций командой `bin/console make:migration`. Внимание!!! Необходимо проверить содержимое только что созданной миграции, в ней должны быть только те изменения, которые необходимы для созданных моделей. У доктрины бывает просачивается отсебятина, надо следить.

4. Выполнение новых миграций `bin/console doctrine:migrations:migrate`

<a name="newTypeData"><h2>Добавленные типы данных</h2></a> 

- list  
 класс `App\Entity\OrmType\ListType` - линейный массив, элементами которого являются строковые данные 
 для такого поля в модели появляются методы:
   - mixed getFrom{List}(integer $index)  
   - $this addTo{List}(mixed $value)  
   - $this removeFrom{List}(mixed $value)

- dict  
 класс `App\Entity\OrmType\DictionaryType` - ассоциативный массив с произвольной структурой 
 для такого поля в модели появляются методы:
   - mixed getFrom{Dict}(string $key)
   - $this addTo{Dict}(string|array $keyOrMap, mixed $value = null)
   - $this removeFrom{Dict}(string $key)

<a name="aboutAttributes"><h2>Описания к полям моделей</h2></a> 

- описываются в отдельных файлах (чтобы не загромождать саму схему модели)
- чтобы сгенерировать файл описания для модели, используется команда `bin/console entity:make-description`
- расположение файлов с описанием полей: `/util/EntityDescriptions`

Пример:
```yaml
# Имя модели
name: Product
# Список полей
attributes:
  # Описание поля на одном языке (не рекомендуется, т.к. хотим поддерживать русский и английский)
  name: Название (заголовок для книг)
  # Описание поля на русском и английском
  type:
    ru: Категория товара
    en: Name of product type
```

<a name="developController"><h2>Проектирование контроллера</h2></a>

Порядок действий:
- Подготовка контроллера (используем аннотации для определения роутинга в проекте, определение некоторых методов)
- Определяем валидационные формы (InputForm - валидация запроса, OutputForm - валидация ответа)
- Запускаем сборку валидационных форм
- Актуализируем документацию

Подробнее:
1. Подготовка контроллера
    - Для определения роутинга с использованием аннотаций подключаем класс:
    use Symfony\Component\Routing\Annotation\Route;
    - У контроллера и каждого метода, который будет экшеном, определяем аннотацию, н-р:
        ```php
      /**
       * @Route("/commonNameRout")
       */
      class NameController extends BaseController
      {
          /**
          * @Route("/rout/{id}", name="name_rout", methods={"GET"})
          */
            public function nameRout()
            {
              
            }
      }
        ```
    - Указание используемого метода ("GET", "POST", "PATCH", "DELETE") обязательно
    - Контроллер наследуем от App\Controller\BaseController
    - Переопределяем метод `getValidationFormsGroupName()`, он возвращает имя, которое будет использоваться для группировки валидационных форм в директории `/util/ValidationForm`, а также для группировки роутов в сваггере
    Пример:  

            /**
             * @return string
             */
            public static function getValidationFormsGroupName()
            {
                return 'Product';
            }
            
    - Для контроллеров в которых будут присутсвовать экшены, требующие авторизации, классы имплементировать интерфейсы `AuthenticationOAuth2Interface` и `AuthorizationRbacInterface`, включать в себя метод
    `getPermissions` который возвращает по названиям экшенов массив ролей, которые имеют доступ к соответствующему экшену.  
     Пример
      ```
      /**
           * @return array|string[]
           */
          public static function getPermissions() : array
          {
              return [
                  'auth' => [UserRolesEnum::CLIENT],
              ];
          }
      ```
      Так же к контроллеру должны быть подключены следующие трейты реализующие логику авторизации и аутентификации пользователей
      `RbacControllerTrait` и `OAuth2AndRbacControllerTrait`.
      
     - Для разработки методов предусмотрен вариант игнорирования валидационных форм метод `getActionsWithoutValidation` в `BaseController` для добавления экшена в игнор нужно в дочернем контроллере переопределить данный метод и вернуть массив с названием экшена, который должен быть проигнорирован.
     Пример:  
     
            public static function getActionsWithoutValidation(): array
            {
                return [
                    'nameAction'
                ];
            }
            
    - В качестве ответа метода контроллера используются методы `prepareResponse` - если во время выполнения запроса не было ошибок и `prepareErrorResponse` - если нужно отдать ошибку.  
     Пример:  
        ```
         public function test(ClassFirst $classFirst, Request $request)
            {
                $data = $request->get('queryParam');
        
                $result = $classFirst->testMethods($data);
                if (!is_null($result)) {
                    return $this->prepareErrorResponse('error get data');
                }
        
                return $this->prepareResponse('ok');
            }
        ```
2. Определяем валидационные формы
    - Запускаем команду, которая подготовит файлы yaml-спецификаций для контроллера:
    `bin/console val-form:renew-for-controller YourController`
    - Команда создаст директорию с именем, возвращаемым методом `getValidationFormsGroupName()`, по пути `/util/ValidationForm`. В этой директории для каждого экшена будет сгенерирован yaml-файл со спецификацией для валидационных форм
    - Пример автоматически сгенерированной спецификации для валидационных форм:
    ```yaml
    MetaData:
      Controller: App\Controller\ProductController
      Action: deleteProduct
      Group: Product
      Method: DELETE
      Path: /product/{id}/delete
      Authentication: required
      SymfonyRouteName: delete_product
    
    # Краткий обобщающий комментарий для метода в сваггере
    Summary: TODO
    # Описание особенностей метода в сваггере (если они есть)
    Description: TODO
    
    # Валидационная форма для входящего запроса
    InputForm: TODO
    
    # Валидационная форма для подготовленного ответа
    OutputForm: TODO
    ```
    - Переходим к этим файлам и описываем формы

    2.1. Определение `Summary` и `Description`:
    - Можно инициализировать строками на одном языке (не рекомендуется, т.к. хотим поддерживать русский и английский)
    ```yaml
    Summary: краткое описание
    Description: особенности
    ```
    - Можно инициализировать массивом с вариантами на русском и английском
    ```yaml
    Summary:
      ru: краткое описание
      en: short description
    Description:
      ru: особенности
      en: features
    ```
    
    2.2. Определение `InputForm`, для бОльших подробностей см. пункт 2.4.
    - Пример:
    ```yaml
    InputForm:
      # Параметры запроса, которые берутся из самого роута, н-р `/some-route/{paramName}`
      path:
        # Определяем: тип обязательно, остальное необязательно (требуется, может быть null, значение по умолчанию, ограничения)
        paramName: string required !nullable default(SomeValue) Enum("SomeEnum")
      # Параметры запроса, которые берутся из параметров запроса, н-р `?param1=val1&param2=val2`
      query:
        # -//-
      # Параметры запроса, которые берутся из заголовков
      header:
        # -//-
      # Параметры запроса, которые берутся из куки
      cookie:
        # -//-
      # Параметры запроса, которые берутся из тела
      body:
        # Описание ко всему телу запроса (это НЕ параметр, служебные поля начинаются на `$`)
        $description:
          en: Data for new product
          ru: Данные для нового товара
        # Это параметр
        someParam: string required !nullable default(SomeValue) Enum("SomeEnum")
        # Импортирование полей указанной модели
        $entity:
          # Имя модели
          $name: Product
          # Можно указать список полей, которые нужно импортировать. По умолчанию берутся все
          $attributes: [...]
          # Можно указать поля, которые не нужно импортировать (фильтрует предыдущий список)
          $except: [id, type, createdAt, updatedAt]
        # Этот параметр - дополнительное вложение в схему
        list:
          param1: string
          param2: string
        # Этот параметр - дополнительное вложение в схему с импортированием полей модели
        detail:
          $entity:
            $name: ProductBook
            $except: [id, createdAt, updatedAt]
    ```
    
    2.3. Определение `OutputForm`, для бОльших подробностей см. пункт 2.4.
    - TODO: требует доработки
    
    2.4. Подробнее об описании форм
    
        # Синтаксис для описания форм. Сокращенный вариант
        InputForm:
          # Параметры, берущиеся из пути запроса
          path:
            name: {{TYPE}} [[REQUIRED]] [[NULLABLE]] [[default(DEFAULT)]] ...[[CONSTRAINT]]
          # Параметры, берущиеся собственно из параметров запроса
          query:
            # ...
          # Параметры, берущиеся из заголовков запроса
          header:
            # ...
          # Параметры, берущиеся из куки
          cookie:
            # ...
          # Параметры, берущиеся из тела запроса
          body:
            # ...
        # Где:
        # {{TYPE}} - обязательно, одно из значений:
        #   [integer, float, string, datetime, boolean, object, list, dict, integer[], float[], string[]]
        # [[REQUIRED]] - опционально, одно из значений [required, !required]
        # [[NULLABLE]] - опционально, одно из значений [nullable, !nullable]
        # [[default(DEFAULT)]] - опционально, в виде default(<значение по умолчанию>)
        # - Для параметров, берущихся из пути запроса, всегда верно `required`, указывать `!required` не имеет смысла
        # - Для остальных параметров по умолчанию равно `!required`
        # ...[[CONSTRAINT]] - опционально, любое количество ограничений
        # - Пример: `Length(min=2, max=10) Enum("SomeEnum") IsTrue()`
        #
        # Задавать описания в данном варианте нельзя
        
        # Синтаксис для описания форм. Расширенный вариант
        InputForm:
          query:
            name:
              $type: {{TYPE}}
              $required: true/false
              $nullable: true/false
              $default: 0
              $description:
                en: --
                ru: --
              $constraints:
                - ...[[CONSTRAINT]]
        
        # Синтаксис для описания форм. Смешанный вариант
        InputForm:
          query:
            name:
              $definition: {{TYPE}} [[REQUIRED]] [[NULLABLE]] [[default(DEFAULT)]] ...[[CONSTRAINT]]
              $description:
                en: --
                ru: --
    
    2.5. Маппинг
    - Возможна следующая шаблонизация валидационных форм, пример:
    ```yaml
    MetaData:
      # ... прочие данные
      # Обратите внимание на `{type}`
      Path: /{type}/create
    
    # Использование алиаса для описания:
    # Признаком алиаса является первый символ `@`
    # Сам алиас является ключом в карте значений (см. Mapping)
    Summary: "@summary"
    
    InputForm:
      body:
        $entity:
          # Использование алиаса для задания имя модели
          $name: "@name"
    
    OutputForm: {}
    
    # Собственно маппинг
    Mapping:
      # По какому полю делать шаблонизацию
      by: type
      # Карта значений для поля шаблонизации с инициализацией алиасов
      map:
        book:
          name: ProductBook
          summary: какое-то описание для данного типа
        e_book:
          name: ProductEBook
          summary: какое-то описание для данного типа
    ```
    - По такой спецификации создастся несколько форм валидации и несколько запросов в сваггере
    - Сделано для детализации запросов по типам данных, пример из проекта - [[App\Controller\ProductController::createProduct]]

3. Запускаем сборку валидационных форм
- Запуск команды `bin/console val-form:compile`
- Можно запустить с указанием имени (имён) группы валидационных форм. Без указания проверяются все группы
- Можно запустить с флагом `-f` (`--force`) для принудительной пересборки всех валидационных форм
- Команда соберет валидационные формы и ресурсы для спецификации сваггера

<a name="swagger"><h2>Актуализация документации (в сваггере)</h2></a>

1. Команда для сборки метаданных спецификации сваггера `bin/console swagger:renew-header`
    - Сваггер имеет раздел "servers", который зависит от конкретной машины
    - Список серверов для сваггера должен быть указан в неверсионном конфиге `/.env.local.php`:
        ```php
        return [
            // ...
            'APP_SWAGGER_SERVERS' => [
                [
                    'url' => 'http://mifapi',
                    'description' => 'Local dev server',
                ],
            ],
        ];
    ```
    - Собранные метаданные для сваггера также неверсионные, находятся по пути `/var/cache/common/swagger/header.json`
    - Нужен запуск этой команды на каждой машине, разово (или на каждый случай внесения изменений в список серверов в неверсионном конфиге)

2. Сборка итоговой спецификации для свагегра осуществляется командой `bin/console swagger:renew`
    - Собирается N файлов, где N - число языков, на которых делались описания к полям в спецификациях, н-р `/swagger/ru.json`
    
<a name="persistHolder"><h2>Особенности работы с doctrine в проекте</h2></a>

С целью оптимизации запросов к БД через ORM doctrine был реализован класс `EntityPersistHolder` который собирает запросы в массив и после заврешения работы с сущностями начинает формирование запросов и выполняет `flush()` сущностей.
В данном классе важны следующие методы:
* `hold` - добавляет в стэк буфер, куда поместятся сущности, требующие изменений
* `commit` - использует стэк буферов, чтобы сохранить все изменения, после чего очищает стэк
* `drop` - скидывает последний буфер в стэке без сохранения

Пример с циклом:  
```php
    Mif::getPersistHolder()->hold();
    foreach ($entityCollection as $entity) {
        $entity->setAttribute('nameAttribute', 1);
        $entity->save();
    }
    Mif::getPersistHolder()->commit();
```
Таким образом после изменения всех сущностей в коллекции появится буферов, содержащий сущности, требующие изменения, после этого коммандой `commit` все изменения сущностей будут сохранены.

Пример с вложенным стэком:
```php
class test 
{
    public function method1($entityCollection, $entityCollections2) 
    {
        Mif::getPersistHolder()->hold();

        // Внутри данного метода также создается буфер
        $this->method2($entityCollections2);

        foreach ($entityCollection as $entity) {
            $entity->setAttribute('nameAttribute', 1);
            $entity->save();
        }

        Mif::getPersistHolder()->commit();
    }
    
    public function method2($entityCollections2)
    {
        Mif::getPersistHolder()->hold();

        foreach ($entityCollections2 as $entity) {
            $entity->setAttribute('nameAttribute', 1);
            $entity->save();
        }

        Mif::getPersistHolder()->commit();
    }
}
```
В данном примере все измененные сущности из метода `method2` будут добавлены в стэк, но в отличии от перого случая изменения не будут внесены в БД до тех пор, пока не отработает цикл в методе `method1`. После того как цикл в первом методе закончится будет вызван метод `commit` и так как в стэке вызова он является последним (верхним) после него изменения будут сохранены.

Для сохранения или удаления одной модели можно использоать методы `save`, `remove`.
Пример:
```php
$entity->save();
$entity->remove();
```
Эти методы определены в классе `BaseEntity`.

<a name="di"><h2>Особенности DI в проекте</h2></a>

Зависимости для классов в проекте можно реализовывать через метод `getSubscribedServices` класса `MifServiceProvider`
после этого класс, который был добавлен к зависимостям, будет доступен в любом месете проекта через конструктию `Mif::getServiceProvider()->YourClass`
Пример `getSubscribedServices`  

    ```
        /**
             * @return array
             */
            public static function getSubscribedServices()
            {
                return [
                    'MyClassSevice' => MyClassSevice::class,
                ];
            }
    ``` 
Так же можно реализовать межсервисные зависимости. Для использования одного сервиса в другом, нужно переопределить метод `subscribedServicesMap`.
Пример:
```php
protected static function subscribedServicesMap()
    {
        return [
            'MyService1' => Myservice1::class,
            'MyService2' => MyService2::class,
        ];
    }
```

После этого в текущем сервисе можно использоать методы подключенного сервиса следующим образом:
```php
$this->MyService1->MyMethod1($param1, $param2);
```
<a name="codeReview"><h2>Принципы код ревью</h2></a>
Код ревью организован в соответствии с процессом гит-флоу.
Алгоритм:
1. В процессе написания кода, разработчик создаёт отдельную ветку от ветки 'develop'. По мере необходимости, делает коммиты и выливает изменения в свою ветку в удалённом репозитории.
2. По итогу процесса написания кода, разработчик актуализирует состояние удалённой ветки (делает коммит и выливает измения), и, если пулл-реквест ещё не был создан, создаёт пулл-реквест на мердж его ветки в ветку 'develop'.
3. Тимлид проверяет вносимые изменения, находящиеся в пулл-реквесте. Отмечает замечания. Если замечания есть, возвращает задачу на доработку (возврат к пункту 2). Если замечаний нет, переход к пункту 4.
4. Осуществляется мердж проверенной ветки в ветку 'develop', пулл-реквест закрывается, проверенная ветка из удалённого репозитория удаляется.

<a name="projDoc"><h2>Принципы документирования проекта</h2></a>
Документирование проекта включает три уровня:
1. Документирование внутренней архитектуры проекта. 
    * Информация, важная для разработчиков.
    * Пример - набор консольных команд для формирования валидационных форм, или алгоритм создания контроллера с определенными требованиями к аутентификации.
    * Находится в едином файле README.md в репозитории проекта.

2. Документирование API проекта.
    * Информация, важная для пользователей API (фронтэнд)
    * Пример - URL для совершения определенной операции, структура данных, ожидаемая программой, структура данных, возвращаемая программой.
    * Находится по URL %домен%/doc. Для тестового сервера полный URL: https://mifapi.miftech.ru/doc.

3. Техническое документирование проекта.
    * Информация, важная для пользовалетей, внешних относительно процесса написания кода (тестировщики, продакт-оунер).
    * Пример - описание ахитектуры виртуальных страниц и прикрепляемых к ним ресурсов, принципов работы и алгоритмов, необходимых для взаимодействия с описываемой системой.
    * Находится в разделе описания соответствующих задач в трекере задач.

<a name="console"><h2>Полезные команды</h2></a>
 
* `sudo update-alternatives --config php` : Переключение между версиями PHP, т.к. удобно для работы с проектом активной иметь нужную версию
* `bin/console entity:generate` - Генерация php-файлов сущностей (моделей) по yaml-конфигурациям
* `bin/console entity:make-description` - Подготовка файла с описаниями атрибутов для сущности (модели)
* `bin/console val-form:renew-for-controller` - Подготовка файлов с описанием валидационных форм для контроллера
* `bin/console val-form:compile` - Сборка валидационных форм
* `bin/console swagger:renew-header` - Сборка общей информации для сваггера
* `bin/console swagger:renew` - Сборка доки по запросам для сваггера
* `bin/console user-set-role [email] [role]` - добавляет указанную роль пользователю по его почте
* `bin/console user-drop-role [email] [role]` - удаляет у пользователя указанную роль
